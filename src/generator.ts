/**
 * OpenAPI to TypeScript Generator
 * Native implementation to replace openapi-typescript
 */

import type {
  GeneratorOptions,
  OpenAPISchema,
  ReferenceObject,
  SchemaObject,
} from './types'

export class OpenAPITypeScriptGenerator {
  private schema: OpenAPISchema
  private options: GeneratorOptions
  private indent = '  '
  private components: Map<string, string> = new Map()

  constructor(schema: OpenAPISchema, options: GeneratorOptions) {
    this.schema = schema
    this.options = options
  }

  /**
   * Generate TypeScript definitions from OpenAPI schema
   */
  generate(): string {
    const parts: string[] = []

    // Header comment
    parts.push('/**')
    parts.push(' * This file was auto-generated by ts-open-api.')
    parts.push(' * DO NOT MAKE DIRECT CHANGES TO THE FILE.')
    parts.push(' */')
    parts.push('')

    // Generate component schemas
    if (this.schema.components?.schemas) {
      parts.push('// Component Schemas')
      parts.push('')

      const schemaNames = Object.keys(this.schema.components.schemas)
      if (this.options.alphabetize) {
        schemaNames.sort()
      }

      for (const name of schemaNames) {
        const schema = this.schema.components.schemas[name]
        const tsType = this.generateSchemaType(schema, 0)

        // Use 'type' for enums and unions, 'interface' for objects
        const isObjectType = tsType.trim().startsWith('{')
        const keyword = isObjectType ? 'interface' : 'type'
        const separator = isObjectType ? ' ' : ' = '

        parts.push(`export ${keyword} ${this.sanitizeName(name)}${separator}${tsType}`)
        parts.push('')
      }
    }

    // Generate paths
    if (this.schema.paths && Object.keys(this.schema.paths).length > 0) {
      parts.push('// API Paths')
      parts.push('')
      parts.push('export interface paths {')

      const pathNames = Object.keys(this.schema.paths)
      if (this.options.alphabetize) {
        pathNames.sort()
      }

      for (const path of pathNames) {
        const pathItem = this.schema.paths[path]
        parts.push(`${this.indent}"${path}": {`)

        // Generate operations (get, post, put, delete, etc.)
        for (const [method, operation] of Object.entries(pathItem)) {
          if (method === 'parameters') continue
          if (!operation || typeof operation !== 'object') continue

          parts.push(`${this.indent}${this.indent}${method}: {`)

          // Parameters
          if (operation.parameters) {
            const params = this.generateParameters(operation.parameters)
            if (params.path) {
              parts.push(`${this.indent}${this.indent}${this.indent}parameters: {`)
              parts.push(`${this.indent}${this.indent}${this.indent}${this.indent}path: ${params.path}`)
              if (params.query) {
                parts.push(`${this.indent}${this.indent}${this.indent}${this.indent}query?: ${params.query}`)
              }
              if (params.header) {
                parts.push(`${this.indent}${this.indent}${this.indent}${this.indent}header?: ${params.header}`)
              }
              parts.push(`${this.indent}${this.indent}${this.indent}}`)
            }
            else if (params.query || params.header) {
              parts.push(`${this.indent}${this.indent}${this.indent}parameters?: {`)
              if (params.query) {
                parts.push(`${this.indent}${this.indent}${this.indent}${this.indent}query?: ${params.query}`)
              }
              if (params.header) {
                parts.push(`${this.indent}${this.indent}${this.indent}${this.indent}header?: ${params.header}`)
              }
              parts.push(`${this.indent}${this.indent}${this.indent}}`)
            }
          }

          // Request body
          if (operation.requestBody) {
            const reqBody = this.generateRequestBody(operation.requestBody)
            if (reqBody) {
              parts.push(`${this.indent}${this.indent}${this.indent}requestBody${operation.requestBody.required ? '' : '?'}: ${reqBody}`)
            }
          }

          // Responses
          if (operation.responses) {
            parts.push(`${this.indent}${this.indent}${this.indent}responses: {`)
            for (const [status, response] of Object.entries(operation.responses)) {
              const respType = this.generateResponse(response)
              parts.push(`${this.indent}${this.indent}${this.indent}${this.indent}${status}: ${respType}`)
            }
            parts.push(`${this.indent}${this.indent}${this.indent}}`)
          }

          parts.push(`${this.indent}${this.indent}}`)
        }

        parts.push(`${this.indent}}`)
      }

      parts.push('}')
      parts.push('')
    }

    // Generate components (responses, parameters, etc.)
    if (this.schema.components) {
      if (this.schema.components.responses) {
        parts.push('// Component Responses')
        parts.push('export interface components {')
        parts.push(`${this.indent}responses: {`)
        for (const [name, response] of Object.entries(this.schema.components.responses)) {
          const respType = this.generateResponse(response)
          parts.push(`${this.indent}${this.indent}"${name}": ${respType}`)
        }
        parts.push(`${this.indent}}`)
        parts.push('}')
        parts.push('')
      }
    }

    return parts.join('\n')
  }

  /**
   * Generate TypeScript type from OpenAPI schema object
   */
  private generateSchemaType(schema: SchemaObject | ReferenceObject, depth: number): string {
    // Handle $ref
    if ('$ref' in schema) {
      return this.resolveRef(schema.$ref)
    }

    // Handle nullable
    const nullable = schema.nullable ? ' | null' : ''

    // Handle enum
    if (schema.enum) {
      const enumValues = schema.enum.map(v =>
        typeof v === 'string' ? `"${v}"` : String(v)
      ).join(' | ')
      return enumValues + nullable
    }

    // Handle allOf, anyOf, oneOf
    if (schema.allOf) {
      const types = schema.allOf.map(s => this.generateSchemaType(s, depth + 1))
      return `(${types.join(' & ')})${nullable}`
    }

    if (schema.anyOf) {
      const types = schema.anyOf.map(s => this.generateSchemaType(s, depth + 1))
      return `(${types.join(' | ')})${nullable}`
    }

    if (schema.oneOf) {
      const types = schema.oneOf.map(s => this.generateSchemaType(s, depth + 1))
      return `(${types.join(' | ')})${nullable}`
    }

    // Handle types
    switch (schema.type) {
      case 'string':
        return `string${nullable}`

      case 'number':
      case 'integer':
        return `number${nullable}`

      case 'boolean':
        return `boolean${nullable}`

      case 'null':
        return 'null'

      case 'array':
        if (schema.items) {
          const itemType = this.generateSchemaType(schema.items, depth + 1)
          return `${itemType}[]${nullable}`
        }
        return `any[]${nullable}`

      case 'object':
        return this.generateObjectType(schema, depth) + nullable

      default:
        // No type specified - check for properties
        if (schema.properties) {
          return this.generateObjectType(schema, depth) + nullable
        }
        return `any${nullable}`
    }
  }

  /**
   * Generate object type
   */
  private generateObjectType(schema: SchemaObject, depth: number): string {
    if (!schema.properties || Object.keys(schema.properties).length === 0) {
      if (schema.additionalProperties === false) {
        return 'Record<string, never>'
      }
      if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {
        const valueType = this.generateSchemaType(schema.additionalProperties, depth + 1)
        return `Record<string, ${valueType}>`
      }
      return 'Record<string, any>'
    }

    const indent = this.indent.repeat(depth + 1)
    const parts: string[] = ['{']

    for (const [propName, propSchema] of Object.entries(schema.properties)) {
      const required = schema.required?.includes(propName)
      const optional = required ? '' : '?'
      const propType = this.generateSchemaType(propSchema, depth + 1)

      // Add description as comment if available
      if ('description' in propSchema && propSchema.description) {
        parts.push(`${indent}/** ${propSchema.description} */`)
      }

      parts.push(`${indent}"${propName}"${optional}: ${propType}`)
    }

    // Handle additional properties
    if (schema.additionalProperties && schema.additionalProperties !== false) {
      if (typeof schema.additionalProperties === 'object') {
        const valueType = this.generateSchemaType(schema.additionalProperties, depth + 1)
        parts.push(`${indent}[key: string]: ${valueType}`)
      }
      else {
        parts.push(`${indent}[key: string]: any`)
      }
    }

    parts.push(this.indent.repeat(depth) + '}')
    return parts.join('\n')
  }

  /**
   * Generate parameters
   */
  private generateParameters(parameters: any[]): {
    path?: string
    query?: string
    header?: string
  } {
    const path: string[] = []
    const query: string[] = []
    const header: string[] = []

    for (const param of parameters) {
      const paramType = param.schema ? this.generateSchemaType(param.schema, 0) : 'any'
      const required = param.required ? '' : '?'
      const paramDef = `"${param.name}"${required}: ${paramType}`

      switch (param.in) {
        case 'path':
          path.push(paramDef)
          break
        case 'query':
          query.push(paramDef)
          break
        case 'header':
          header.push(paramDef)
          break
      }
    }

    return {
      path: path.length > 0 ? `{ ${path.join('; ')} }` : undefined,
      query: query.length > 0 ? `{ ${query.join('; ')} }` : undefined,
      header: header.length > 0 ? `{ ${header.join('; ')} }` : undefined,
    }
  }

  /**
   * Generate request body type
   */
  private generateRequestBody(requestBody: any): string | undefined {
    if ('$ref' in requestBody) {
      return this.resolveRef(requestBody.$ref)
    }

    if (!requestBody.content) return undefined

    // Get the first content type (usually application/json)
    const contentType = Object.keys(requestBody.content)[0]
    const mediaType = requestBody.content[contentType]

    if (mediaType.schema) {
      return this.generateSchemaType(mediaType.schema, 0)
    }

    return undefined
  }

  /**
   * Generate response type
   */
  private generateResponse(response: any): string {
    if ('$ref' in response) {
      return this.resolveRef(response.$ref)
    }

    if (!response.content) {
      return '{ status: number; body?: never }'
    }

    const contentTypes = Object.keys(response.content)
    if (contentTypes.length === 0) {
      return '{ status: number; body?: never }'
    }

    // Get the first content type
    const contentType = contentTypes[0]
    const mediaType = response.content[contentType]

    if (mediaType.schema) {
      const bodyType = this.generateSchemaType(mediaType.schema, 0)
      return `{ status: number; body: ${bodyType} }`
    }

    return '{ status: number; body?: any }'
  }

  /**
   * Resolve $ref to TypeScript type
   */
  private resolveRef(ref: string): string {
    // Remove #/components/ prefix and get the component type and name
    const parts = ref.replace('#/components/', '').split('/')
    if (parts.length === 2) {
      return this.sanitizeName(parts[1])
    }
    return 'unknown'
  }

  /**
   * Sanitize name to be a valid TypeScript identifier
   */
  private sanitizeName(name: string): string {
    // Replace invalid characters with underscore
    return name.replace(/[^a-zA-Z0-9_]/g, '_')
  }
}

/**
 * Generate TypeScript definitions from OpenAPI schema
 */
export async function generateTypes(options: GeneratorOptions): Promise<void> {
  const { input, output } = options

  // Read OpenAPI schema
  const schemaContent = await Bun.file(input).text()
  const schema: OpenAPISchema = JSON.parse(schemaContent)

  // Generate TypeScript
  const generator = new OpenAPITypeScriptGenerator(schema, options)
  const typescript = generator.generate()

  // Write output
  await Bun.write(output, typescript)

  if (!options.silent) {
    console.log(`âœ… Generated TypeScript definitions: ${output}`)
  }
}
